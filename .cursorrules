# qzWhatNext – Cursor Rules

These rules ensure AI assistance follows qzWhatNext's core principles and critical enforcement requirements. **For detailed specifications, always consult the canonical documents** (see References section below).

---

## Critical Enforcement Rules

### AI Exclusion (MUST ENFORCE BEFORE ANY AI CALL)

A task is AI-excluded if:
- Its title begins with a period (`.`)
- OR the user explicitly flags it as `ai_excluded: true`

**AI-excluded tasks:**
- Are NEVER sent to AI (check this BEFORE any AI call)
- Never receive AI-updated attributes
- Never change tiers due to AI inference
- May still be scheduled deterministically

**This is the most critical rule. Violating it breaks user trust.**

### Core Non-Negotiable Principles

**Trust over optimization**
- User trust is prioritized over efficiency or utilization
- Predictable behavior is preferred over optimal outcomes
- Surprising behavior is avoided even if suboptimal

**Deterministic rules override AI**
- AI may assist with inference but never controls outcomes
- Rules engine makes authoritative decisions, not AI
- Same inputs must always produce same outputs

**Explainability and reversibility**
- Every system action must have a one-line explanation derived from structured reasons
- All actions must be reversible
- No free-form AI explanations in MVP (use templates with structured reasons)

**Privacy-first approach**
- No user data is shared with third parties
- AI-excluded tasks are never sent to AI
- Sensitive tasks are fully supported

### AI Responsibilities

**AI may infer** (with confidence scores):
- Structured attributes: category, duration, energy_intensity, risk_score, impact_score, dependencies
- See `context-pack.md` section 4.2 for full list

**AI may NOT:**
- Assign priority tiers (rules engine does this)
- Override hard constraints
- Move user-blocked or manually scheduled time
- Generate free-form user-facing explanations (MVP)
- Operate on AI-excluded tasks

### Architectural Constraints (Quick Reference)

- Every task has exactly ONE governing priority tier (see `context-pack.md` section 6 for hierarchy)
- Transition Time is system-generated, NOT a task category (see `engine/transition-time.md`)
- System may move ONLY tasks it scheduled itself
- System may NOT move user-blocked time or manually scheduled events
- Default scheduling granularity: 30 minutes

---

## Common Pitfalls to Avoid

- ❌ Sending AI-excluded tasks to AI (check BEFORE any AI call)
- ❌ Allowing AI to assign priority tiers
- ❌ Moving user-blocked or manually scheduled time
- ❌ Silent failures or dropped tasks
- ❌ Non-deterministic behavior in core engine
- ❌ Free-form AI explanations (use templates)
- ❌ Treating Transition Time as a task category
- ❌ Reordering the fixed priority hierarchy
- ❌ Skipping audit logging for trust-critical actions

---

## Code Quality Standards

**Deterministic Behavior**
- Same inputs → same outputs (no randomness in core logic)
- Rebuilds must be deterministic given identical inputs

**Error Handling**
- No silent failures
- Overflow tasks must be surfaced with one-line explanation
- When work exceeds capacity: protect high-importance tasks, defer lower-tier, notify user

**Audit Logging**
- Log all trust-critical actions (imports, tier changes, schedule builds, etc.)
- Logs must be queryable for trust and debugging

---

## General Development Guidelines

**Minimal Changes Principle**
- Don't refactor code unless it's absolutely necessary for the current task
- Make the smallest change that solves the problem
- Preserve existing patterns and conventions unless they conflict with requirements
- Don't "improve" code that isn't related to the current task

**Scope and Communication**
- Ask before making large architectural changes
- Don't rewrite entire files unless explicitly requested
- When in doubt, implement the simplest solution that meets requirements
- Don't add features or optimizations beyond what's requested

**Code Preservation**
- Maintain existing code style and formatting
- Don't change working code "just because"
- Preserve comments and documentation unless they're incorrect
- Keep existing test structure unless tests need to change for new functionality

**Incremental Development**
- Build features incrementally
- Test as you go
- Don't over-engineer solutions
- Prefer working code over perfect code

---

## Testing Guidelines

**Deterministic Testing**
- All tests must be deterministic (same inputs → same outputs)
- Use fixed test data, never random seeds in core logic tests
- Test AI exclusion enforcement explicitly
- Test hard constraint violations (user-blocked time, manually scheduled events)
- Test tier assignment logic deterministically

**Test Coverage Priorities**
- Test trust-critical paths first (AI exclusion, tier assignment, scheduling constraints)
- Test overflow detection and notification
- Test audit logging for all trust-critical actions
- Test reversibility of all system actions

**Test Data**
- Use deterministic fixtures
- Avoid time-dependent tests unless testing time-specific behavior
- Mock external APIs (Todoist) to ensure deterministic behavior

---

## Security & Privacy Implementation

**Data Protection**
- Never log sensitive task data (titles, notes) in plain text
- Encrypt sensitive data at rest
- Use environment variables for API keys and secrets
- Never commit secrets or credentials to version control

**Input Validation**
- Validate all external API inputs (Todoist, calendar APIs)
- Sanitize user inputs before processing
- Reject invalid data with clear, structured error messages
- Never trust external API responses without validation

**Privacy Enforcement**
- AI-excluded tasks must never appear in logs or analytics
- Audit logs should reference task IDs, not task content for excluded tasks
- Implement data retention policies for user data

---

## Data Validation

**Validation Requirements**
- Validate all inputs before processing (task data, API responses, user inputs)
- Validate data model fields match canonical spec (see `engine/scoring-and-scheduling.md`)
- Reject invalid data with structured error messages (not free-form)
- Never process data that fails validation

**Validation Points**
- On task import (normalize and validate)
- Before AI inference (check exclusion rules first)
- Before tier assignment (validate required attributes)
- Before scheduling (validate constraints)

---

## API/Integration Design

**External API Handling**
- Handle API failures gracefully (network errors, rate limits, timeouts)
- Implement retry logic with exponential backoff
- Rate limit external API calls appropriately
- Cache API responses when appropriate (respecting data freshness)

**Error Handling**
- Never fail silently on API errors
- Log API failures with context (but not sensitive data)
- Surface API errors to user with structured explanations
- Implement fallback behavior when APIs are unavailable

**Integration Patterns**
- Use type-safe API clients when possible
- Validate all API responses against expected schemas
- Handle API version changes gracefully
- Document API dependencies and rate limits

---

## Error Messages & User Communication

**Error Message Standards**
- Use structured error templates (not free-form AI-generated text)
- Include one-line explanations derived from structured reasons
- Never expose internal errors or stack traces to users
- Provide actionable guidance when possible

**User-Facing Messages**
- All system actions must have explainable outcomes
- Error messages must align with trust principles (transparent, reversible)
- Use consistent message formatting across the system
- Reference decision IDs from `decision-log/decisions.md` in technical error logs

---

## Configuration & Secrets Management

**Configuration**
- Use environment variables for configuration
- Provide sensible defaults for all configuration options
- Validate configuration on startup
- Document all configuration options

**Secrets Management**
- Never hardcode API keys, tokens, or credentials
- Use secure secret management (environment variables, secret managers)
- Rotate secrets regularly
- Never log secrets or credentials

---

## Type Safety & Code Documentation

**Type Safety**
- Prefer type-safe languages when possible
- Use strong typing for data models (Task, Transition, ScheduledBlock)
- Use enums/types for fixed hierarchies (priority tiers, categories, energy levels)
- Validate types at runtime for external data (API responses)

**Code Documentation**
- Document complex logic, especially deterministic rules
- Reference decision IDs from `decision-log/decisions.md` in code comments
- Explain why deterministic rules override AI in complex logic
- Document confidence thresholds for tier changes
- Keep documentation in sync with code changes

---

## Git & Version Control Practices

**Commit Messages**
- Use clear, descriptive commit messages
- Reference relevant decision IDs or canonical docs when applicable
- Keep commits focused (one logical change per commit)
- Use conventional commit format when helpful

**Branching & Workflow**
- Keep main branch stable and deployable
- Use feature branches for new functionality
- Review changes before merging to main
- Tag releases appropriately

---

## Question-Asking Guidelines

**When to Ask**
- Before making large architectural changes
- When requirements are ambiguous or conflicting
- When multiple valid implementations exist
- Before adding features beyond the current task scope

**When to Proceed**
- When requirements are clear from canonical docs
- When following established patterns
- When implementing straightforward fixes or features
- When the simplest solution is obvious

**Communication Style**
- Ask specific questions, not open-ended ones
- Provide context about what you're trying to achieve
- Reference relevant canonical docs in questions
- Suggest solutions when asking questions

---

## References to Canonical Documents

**When implementing or making decisions, consult these documents:**

1. **`context-pack.md`** - Global rules, product identity, priority hierarchy, AI guardrails
2. **`decision-log/decisions.md`** - All locked architectural and product decisions
3. **`engine/scoring-and-scheduling.md`** - Engine spec, data models, pipeline, scheduling algorithm
4. **`prd/prd.md`** - MVP scope and requirements

**For specific details:**
- **Priority tier hierarchy** → `context-pack.md` section 6.1
- **Data model fields** → `engine/scoring-and-scheduling.md` section 2
- **Engine pipeline steps** → `engine/scoring-and-scheduling.md` section 4
- **AI guardrails (detailed)** → `context-pack.md` section 4 and `security/ai-guardrails.md`
- **Transition Time rules** → `engine/transition-time.md` and `context-pack.md` section 7
- **Scheduling algorithm** → `engine/scoring-and-scheduling.md` section 13
- **Energy budgeting** → `engine/scoring-and-scheduling.md` section 11

**Canonical Rule:** "Chats generate artifacts. Artifacts replace chats."

---

## Success Criteria

Code is correct when:
- ✅ AI exclusion is enforced before any AI call
- ✅ Priority tiers are assigned deterministically by rules engine
- ✅ User-blocked time is never moved
- ✅ Every system action has a one-line explanation
- ✅ All actions are reversible
- ✅ Same inputs produce same outputs
- ✅ Overflow is detected and notified (never silent)
- ✅ Audit logs capture all trust-critical actions
